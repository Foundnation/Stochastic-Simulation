import multiprocessing
import os
import time
from tsp_annealing import *

script_directory = os.path.dirname(os.path.abspath(__file__))
filepath = os.path.join(script_directory, 'TSP-Configurations/eil51.tsp.txt')

cities = load_graph(filepath)
distances = calculate_distances(cities)
max_iterations = int(1E6)
final_temp = 1E-8
cooling_schedule = 'quadratic_a'
alpha = 1 - 1E-7
distances = calculate_distances(cities)

# Define a function for performing annealing with specified arguments
def perform_annealing_wrapper(**kwargs):
    # Add process output to verify concurrency
    process_id = os.getpid()
    print(f"Process ID: {process_id} - Starting annealing process")
    
    # Perform the annealing process
    result = perform_annealing(**kwargs)
    
    # Add process output to indicate completion
    print(f"Process ID: {process_id} - Annealing process completed")
    return result

if __name__ == "__main__":
    # Prepare keyword arguments for perform_annealing
    annealing_kwargs = {
        'distances': distances,
        'altering_method': 'swap',
        'max_iterations': max_iterations,
        'final_temp': final_temp,
        'cooling_schedule': cooling_schedule,
        'alpha': alpha
    }
    
    # Determine the number of available CPU cores
    num_processes = multiprocessing.cpu_count() * 2  # Adjust this value as needed
    
    # Measure time taken without concurrency
    start_time_no_concurrency = time.time()
    for _ in range(3):
        perform_annealing_wrapper(**annealing_kwargs)
    end_time_no_concurrency = time.time()
    
    # Create a pool of processes and measure time taken with concurrency
    start_time_concurrency = time.time()
    with multiprocessing.Pool(processes=num_processes) as pool:
        # Submit tasks to the pool
        results = [pool.apply_async(perform_annealing_wrapper, kwds=annealing_kwargs) for _ in range(3)]
        
        # Retrieve results from the pool
        output = [res.get() for res in results]
    end_time_concurrency = time.time()
    
    # Calculate and print the time taken for both scenarios
    time_taken_no_concurrency = end_time_no_concurrency - start_time_no_concurrency
    time_taken_concurrency = end_time_concurrency - start_time_concurrency
    
    print(f"Time taken without concurrency: {time_taken_no_concurrency} seconds")
    print(f"Time taken with concurrency: {time_taken_concurrency} seconds")